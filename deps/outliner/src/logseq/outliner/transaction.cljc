(ns logseq.outliner.transaction
  #?(:cljs (:require-macros [logseq.outliner.transaction]))
  #?(:cljs (:require [malli.core :as m]
                     [logseq.outliner.core :as outliner-core]
                     [promesa.core :as p])))

(def transact-opts [:or :symbol :map])

#?(:cljs (m/=> transact! [:=> [:cat transact-opts :any] :any]))

(defmacro transact!
  "Batch all the transactions in `body` to a single transaction, Support nested transact! calls.
  It'll execute body and collect all transaction data generated by body.
  If no transactions are included in `body`, it does not save a transaction.
  `Args`:
    `opts`: Every key is optional, opts except `additional-tx` will be transacted as `tx-meta`.
            {:outliner-op \"For example, :save-block, :insert-blocks, etc. \"
             :additional-tx \"Additional tx data that can be bundled together
                              with the body in this macro.\"
             :persist-op? \"Boolean, store ops into db (sqlite), by default,
                            its value depends on (config/db-based-graph? repo)\"}
  `Example`:
  (transact! {:transact-opts {:repo \"test\"
                              :conn db-conn}
              :additional-tx [{:db/id 1 :block/left 2}]}
    (insert-blocks! ...)
    ;; do something
    (move-blocks! ...)
    (delete-blocks! ...))"
  [opts & body]
  `(let [*opts# outliner-core/*transaction-opts
         *transact-data# outliner-core/*transaction-data
         *batch-transacting# outliner-core/*batch-transacting?]
     (swap! *opts# merge ~opts)
     (if @*batch-transacting#
       (do
         (prn :debug :nested-transaction)
         ~@body)
       (do
         (reset! *batch-transacting# true)
         (p/let [_result# (do ~@body)
                 tx-data# (concat (reverse (mapcat :tx-data @*transact-data#)) (:additional-tx @*opts#))
                 transact-opts# (:transact-opts @*opts#)
                 tx-meta# (merge (dissoc @*opts# :additional-tx :current-block :transact-opts)
                                 (first (map :tx-meta @*transact-data#)))
                 tx-meta## (cond-> tx-meta#
                             (get :persist-op? true)
                             (assoc :persist-op? true))
                 result# (logseq.outliner.datascript/transact! tx-data# tx-meta## transact-opts#)]
           (prn :debug :transact-here tx-data#)
           (outliner-core/finish-batch-transact!)
           result#)))))
